// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package languagesmock

import (
	"github.com/espal-digital-development/espal-core/repositories/languages"
	"sync"
)

var (
	lockDataMockAlternativeEnglishName sync.RWMutex
	lockDataMockCode                   sync.RWMutex
	lockDataMockEnglishName            sync.RWMutex
	lockDataMockID                     sync.RWMutex
	lockDataMockSetTranslation         sync.RWMutex
	lockDataMockTranslate              sync.RWMutex
)

// Ensure, that DataMock does implement languages.Data.
// If this is not the case, regenerate this file with moq.
var _ languages.Data = &DataMock{}

// DataMock is a mock implementation of languages.Data.
//
//     func TestSomethingThatUsesData(t *testing.T) {
//
//         // make and configure a mocked languages.Data
//         mockedData := &DataMock{
//             AlternativeEnglishNameFunc: func() string {
// 	               panic("mock out the AlternativeEnglishName method")
//             },
//             CodeFunc: func() string {
// 	               panic("mock out the Code method")
//             },
//             EnglishNameFunc: func() string {
// 	               panic("mock out the EnglishName method")
//             },
//             IDFunc: func() uint16 {
// 	               panic("mock out the ID method")
//             },
//             SetTranslationFunc: func(languageID uint16, value string)  {
// 	               panic("mock out the SetTranslation method")
//             },
//             TranslateFunc: func(localeID uint16) string {
// 	               panic("mock out the Translate method")
//             },
//         }
//
//         // use mockedData in code that requires languages.Data
//         // and then make assertions.
//
//     }
type DataMock struct {
	// AlternativeEnglishNameFunc mocks the AlternativeEnglishName method.
	AlternativeEnglishNameFunc func() string

	// CodeFunc mocks the Code method.
	CodeFunc func() string

	// EnglishNameFunc mocks the EnglishName method.
	EnglishNameFunc func() string

	// IDFunc mocks the ID method.
	IDFunc func() uint16

	// SetTranslationFunc mocks the SetTranslation method.
	SetTranslationFunc func(languageID uint16, value string)

	// TranslateFunc mocks the Translate method.
	TranslateFunc func(localeID uint16) string

	// calls tracks calls to the methods.
	calls struct {
		// AlternativeEnglishName holds details about calls to the AlternativeEnglishName method.
		AlternativeEnglishName []struct {
		}
		// Code holds details about calls to the Code method.
		Code []struct {
		}
		// EnglishName holds details about calls to the EnglishName method.
		EnglishName []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// SetTranslation holds details about calls to the SetTranslation method.
		SetTranslation []struct {
			// LanguageID is the languageID argument value.
			LanguageID uint16
			// Value is the value argument value.
			Value string
		}
		// Translate holds details about calls to the Translate method.
		Translate []struct {
			// LocaleID is the localeID argument value.
			LocaleID uint16
		}
	}
}

// AlternativeEnglishName calls AlternativeEnglishNameFunc.
func (mock *DataMock) AlternativeEnglishName() string {
	if mock.AlternativeEnglishNameFunc == nil {
		panic("DataMock.AlternativeEnglishNameFunc: method is nil but Data.AlternativeEnglishName was just called")
	}
	callInfo := struct {
	}{}
	lockDataMockAlternativeEnglishName.Lock()
	mock.calls.AlternativeEnglishName = append(mock.calls.AlternativeEnglishName, callInfo)
	lockDataMockAlternativeEnglishName.Unlock()
	return mock.AlternativeEnglishNameFunc()
}

// AlternativeEnglishNameCalls gets all the calls that were made to AlternativeEnglishName.
// Check the length with:
//     len(mockedData.AlternativeEnglishNameCalls())
func (mock *DataMock) AlternativeEnglishNameCalls() []struct {
} {
	var calls []struct {
	}
	lockDataMockAlternativeEnglishName.RLock()
	calls = mock.calls.AlternativeEnglishName
	lockDataMockAlternativeEnglishName.RUnlock()
	return calls
}

// Code calls CodeFunc.
func (mock *DataMock) Code() string {
	if mock.CodeFunc == nil {
		panic("DataMock.CodeFunc: method is nil but Data.Code was just called")
	}
	callInfo := struct {
	}{}
	lockDataMockCode.Lock()
	mock.calls.Code = append(mock.calls.Code, callInfo)
	lockDataMockCode.Unlock()
	return mock.CodeFunc()
}

// CodeCalls gets all the calls that were made to Code.
// Check the length with:
//     len(mockedData.CodeCalls())
func (mock *DataMock) CodeCalls() []struct {
} {
	var calls []struct {
	}
	lockDataMockCode.RLock()
	calls = mock.calls.Code
	lockDataMockCode.RUnlock()
	return calls
}

// EnglishName calls EnglishNameFunc.
func (mock *DataMock) EnglishName() string {
	if mock.EnglishNameFunc == nil {
		panic("DataMock.EnglishNameFunc: method is nil but Data.EnglishName was just called")
	}
	callInfo := struct {
	}{}
	lockDataMockEnglishName.Lock()
	mock.calls.EnglishName = append(mock.calls.EnglishName, callInfo)
	lockDataMockEnglishName.Unlock()
	return mock.EnglishNameFunc()
}

// EnglishNameCalls gets all the calls that were made to EnglishName.
// Check the length with:
//     len(mockedData.EnglishNameCalls())
func (mock *DataMock) EnglishNameCalls() []struct {
} {
	var calls []struct {
	}
	lockDataMockEnglishName.RLock()
	calls = mock.calls.EnglishName
	lockDataMockEnglishName.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *DataMock) ID() uint16 {
	if mock.IDFunc == nil {
		panic("DataMock.IDFunc: method is nil but Data.ID was just called")
	}
	callInfo := struct {
	}{}
	lockDataMockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	lockDataMockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//     len(mockedData.IDCalls())
func (mock *DataMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	lockDataMockID.RLock()
	calls = mock.calls.ID
	lockDataMockID.RUnlock()
	return calls
}

// SetTranslation calls SetTranslationFunc.
func (mock *DataMock) SetTranslation(languageID uint16, value string) {
	if mock.SetTranslationFunc == nil {
		panic("DataMock.SetTranslationFunc: method is nil but Data.SetTranslation was just called")
	}
	callInfo := struct {
		LanguageID uint16
		Value      string
	}{
		LanguageID: languageID,
		Value:      value,
	}
	lockDataMockSetTranslation.Lock()
	mock.calls.SetTranslation = append(mock.calls.SetTranslation, callInfo)
	lockDataMockSetTranslation.Unlock()
	mock.SetTranslationFunc(languageID, value)
}

// SetTranslationCalls gets all the calls that were made to SetTranslation.
// Check the length with:
//     len(mockedData.SetTranslationCalls())
func (mock *DataMock) SetTranslationCalls() []struct {
	LanguageID uint16
	Value      string
} {
	var calls []struct {
		LanguageID uint16
		Value      string
	}
	lockDataMockSetTranslation.RLock()
	calls = mock.calls.SetTranslation
	lockDataMockSetTranslation.RUnlock()
	return calls
}

// Translate calls TranslateFunc.
func (mock *DataMock) Translate(localeID uint16) string {
	if mock.TranslateFunc == nil {
		panic("DataMock.TranslateFunc: method is nil but Data.Translate was just called")
	}
	callInfo := struct {
		LocaleID uint16
	}{
		LocaleID: localeID,
	}
	lockDataMockTranslate.Lock()
	mock.calls.Translate = append(mock.calls.Translate, callInfo)
	lockDataMockTranslate.Unlock()
	return mock.TranslateFunc(localeID)
}

// TranslateCalls gets all the calls that were made to Translate.
// Check the length with:
//     len(mockedData.TranslateCalls())
func (mock *DataMock) TranslateCalls() []struct {
	LocaleID uint16
} {
	var calls []struct {
		LocaleID uint16
	}
	lockDataMockTranslate.RLock()
	calls = mock.calls.Translate
	lockDataMockTranslate.RUnlock()
	return calls
}
