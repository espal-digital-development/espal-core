// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domainmock

import (
	"github.com/espal-digital-development/espal-core/database/filters"
	"github.com/espal-digital-development/espal-core/stores/domain"
	"sync"
)

var (
	lockStoreMockAll                   sync.RWMutex
	lockStoreMockDelete                sync.RWMutex
	lockStoreMockFilter                sync.RWMutex
	lockStoreMockGetOne                sync.RWMutex
	lockStoreMockGetOneActiveByHost    sync.RWMutex
	lockStoreMockGetOneByIDWithCreator sync.RWMutex
	lockStoreMockToggleActive          sync.RWMutex
)

// Ensure, that StoreMock does implement domain.Store.
// If this is not the case, regenerate this file with moq.
var _ domain.Store = &StoreMock{}

// StoreMock is a mock implementation of domain.Store.
//
//     func TestSomethingThatUsesStore(t *testing.T) {
//
//         // make and configure a mocked domain.Store
//         mockedStore := &StoreMock{
//             AllFunc: func() ([]*domain.Domain, bool, error) {
// 	               panic("mock out the All method")
//             },
//             DeleteFunc: func(ids []string) error {
// 	               panic("mock out the Delete method")
//             },
//             FilterFunc: func(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error) {
// 	               panic("mock out the Filter method")
//             },
//             GetOneFunc: func(id string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOne method")
//             },
//             GetOneActiveByHostFunc: func(host string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOneActiveByHost method")
//             },
//             GetOneByIDWithCreatorFunc: func(id string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOneByIDWithCreator method")
//             },
//             ToggleActiveFunc: func(ids []string) error {
// 	               panic("mock out the ToggleActive method")
//             },
//         }
//
//         // use mockedStore in code that requires domain.Store
//         // and then make assertions.
//
//     }
type StoreMock struct {
	// AllFunc mocks the All method.
	AllFunc func() ([]*domain.Domain, bool, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ids []string) error

	// FilterFunc mocks the Filter method.
	FilterFunc func(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error)

	// GetOneFunc mocks the GetOne method.
	GetOneFunc func(id string) (*domain.Domain, bool, error)

	// GetOneActiveByHostFunc mocks the GetOneActiveByHost method.
	GetOneActiveByHostFunc func(host string) (*domain.Domain, bool, error)

	// GetOneByIDWithCreatorFunc mocks the GetOneByIDWithCreator method.
	GetOneByIDWithCreatorFunc func(id string) (*domain.Domain, bool, error)

	// ToggleActiveFunc mocks the ToggleActive method.
	ToggleActiveFunc func(ids []string) error

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ids is the ids argument value.
			Ids []string
		}
		// Filter holds details about calls to the Filter method.
		Filter []struct {
			// Context is the context argument value.
			Context filters.QueryReader
		}
		// GetOne holds details about calls to the GetOne method.
		GetOne []struct {
			// ID is the id argument value.
			ID string
		}
		// GetOneActiveByHost holds details about calls to the GetOneActiveByHost method.
		GetOneActiveByHost []struct {
			// Host is the host argument value.
			Host string
		}
		// GetOneByIDWithCreator holds details about calls to the GetOneByIDWithCreator method.
		GetOneByIDWithCreator []struct {
			// ID is the id argument value.
			ID string
		}
		// ToggleActive holds details about calls to the ToggleActive method.
		ToggleActive []struct {
			// Ids is the ids argument value.
			Ids []string
		}
	}
}

// All calls AllFunc.
func (mock *StoreMock) All() ([]*domain.Domain, bool, error) {
	if mock.AllFunc == nil {
		panic("StoreMock.AllFunc: method is nil but Store.All was just called")
	}
	callInfo := struct {
	}{}
	lockStoreMockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	lockStoreMockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//     len(mockedStore.AllCalls())
func (mock *StoreMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	lockStoreMockAll.RLock()
	calls = mock.calls.All
	lockStoreMockAll.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *StoreMock) Delete(ids []string) error {
	if mock.DeleteFunc == nil {
		panic("StoreMock.DeleteFunc: method is nil but Store.Delete was just called")
	}
	callInfo := struct {
		Ids []string
	}{
		Ids: ids,
	}
	lockStoreMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockStoreMockDelete.Unlock()
	return mock.DeleteFunc(ids)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedStore.DeleteCalls())
func (mock *StoreMock) DeleteCalls() []struct {
	Ids []string
} {
	var calls []struct {
		Ids []string
	}
	lockStoreMockDelete.RLock()
	calls = mock.calls.Delete
	lockStoreMockDelete.RUnlock()
	return calls
}

// Filter calls FilterFunc.
func (mock *StoreMock) Filter(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error) {
	if mock.FilterFunc == nil {
		panic("StoreMock.FilterFunc: method is nil but Store.Filter was just called")
	}
	callInfo := struct {
		Context filters.QueryReader
	}{
		Context: context,
	}
	lockStoreMockFilter.Lock()
	mock.calls.Filter = append(mock.calls.Filter, callInfo)
	lockStoreMockFilter.Unlock()
	return mock.FilterFunc(context)
}

// FilterCalls gets all the calls that were made to Filter.
// Check the length with:
//     len(mockedStore.FilterCalls())
func (mock *StoreMock) FilterCalls() []struct {
	Context filters.QueryReader
} {
	var calls []struct {
		Context filters.QueryReader
	}
	lockStoreMockFilter.RLock()
	calls = mock.calls.Filter
	lockStoreMockFilter.RUnlock()
	return calls
}

// GetOne calls GetOneFunc.
func (mock *StoreMock) GetOne(id string) (*domain.Domain, bool, error) {
	if mock.GetOneFunc == nil {
		panic("StoreMock.GetOneFunc: method is nil but Store.GetOne was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockStoreMockGetOne.Lock()
	mock.calls.GetOne = append(mock.calls.GetOne, callInfo)
	lockStoreMockGetOne.Unlock()
	return mock.GetOneFunc(id)
}

// GetOneCalls gets all the calls that were made to GetOne.
// Check the length with:
//     len(mockedStore.GetOneCalls())
func (mock *StoreMock) GetOneCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStoreMockGetOne.RLock()
	calls = mock.calls.GetOne
	lockStoreMockGetOne.RUnlock()
	return calls
}

// GetOneActiveByHost calls GetOneActiveByHostFunc.
func (mock *StoreMock) GetOneActiveByHost(host string) (*domain.Domain, bool, error) {
	if mock.GetOneActiveByHostFunc == nil {
		panic("StoreMock.GetOneActiveByHostFunc: method is nil but Store.GetOneActiveByHost was just called")
	}
	callInfo := struct {
		Host string
	}{
		Host: host,
	}
	lockStoreMockGetOneActiveByHost.Lock()
	mock.calls.GetOneActiveByHost = append(mock.calls.GetOneActiveByHost, callInfo)
	lockStoreMockGetOneActiveByHost.Unlock()
	return mock.GetOneActiveByHostFunc(host)
}

// GetOneActiveByHostCalls gets all the calls that were made to GetOneActiveByHost.
// Check the length with:
//     len(mockedStore.GetOneActiveByHostCalls())
func (mock *StoreMock) GetOneActiveByHostCalls() []struct {
	Host string
} {
	var calls []struct {
		Host string
	}
	lockStoreMockGetOneActiveByHost.RLock()
	calls = mock.calls.GetOneActiveByHost
	lockStoreMockGetOneActiveByHost.RUnlock()
	return calls
}

// GetOneByIDWithCreator calls GetOneByIDWithCreatorFunc.
func (mock *StoreMock) GetOneByIDWithCreator(id string) (*domain.Domain, bool, error) {
	if mock.GetOneByIDWithCreatorFunc == nil {
		panic("StoreMock.GetOneByIDWithCreatorFunc: method is nil but Store.GetOneByIDWithCreator was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockStoreMockGetOneByIDWithCreator.Lock()
	mock.calls.GetOneByIDWithCreator = append(mock.calls.GetOneByIDWithCreator, callInfo)
	lockStoreMockGetOneByIDWithCreator.Unlock()
	return mock.GetOneByIDWithCreatorFunc(id)
}

// GetOneByIDWithCreatorCalls gets all the calls that were made to GetOneByIDWithCreator.
// Check the length with:
//     len(mockedStore.GetOneByIDWithCreatorCalls())
func (mock *StoreMock) GetOneByIDWithCreatorCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockStoreMockGetOneByIDWithCreator.RLock()
	calls = mock.calls.GetOneByIDWithCreator
	lockStoreMockGetOneByIDWithCreator.RUnlock()
	return calls
}

// ToggleActive calls ToggleActiveFunc.
func (mock *StoreMock) ToggleActive(ids []string) error {
	if mock.ToggleActiveFunc == nil {
		panic("StoreMock.ToggleActiveFunc: method is nil but Store.ToggleActive was just called")
	}
	callInfo := struct {
		Ids []string
	}{
		Ids: ids,
	}
	lockStoreMockToggleActive.Lock()
	mock.calls.ToggleActive = append(mock.calls.ToggleActive, callInfo)
	lockStoreMockToggleActive.Unlock()
	return mock.ToggleActiveFunc(ids)
}

// ToggleActiveCalls gets all the calls that were made to ToggleActive.
// Check the length with:
//     len(mockedStore.ToggleActiveCalls())
func (mock *StoreMock) ToggleActiveCalls() []struct {
	Ids []string
} {
	var calls []struct {
		Ids []string
	}
	lockStoreMockToggleActive.RLock()
	calls = mock.calls.ToggleActive
	lockStoreMockToggleActive.RUnlock()
	return calls
}
