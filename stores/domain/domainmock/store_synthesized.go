// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domainmock

import (
	"github.com/espal-digital-development/espal-core/database/filters"
	"github.com/espal-digital-development/espal-core/stores/domain"
	"sync"
)

// Ensure, that StoreMock does implement domain.Store.
// If this is not the case, regenerate this file with moq.
var _ domain.Store = &StoreMock{}

// StoreMock is a mock implementation of domain.Store.
//
//     func TestSomethingThatUsesStore(t *testing.T) {
//
//         // make and configure a mocked domain.Store
//         mockedStore := &StoreMock{
//             AllFunc: func() ([]*domain.Domain, bool, error) {
// 	               panic("mock out the All method")
//             },
//             AllForSiteIDFunc: func(siteID string) ([]*domain.Domain, bool, error) {
// 	               panic("mock out the AllForSiteID method")
//             },
//             DeleteFunc: func(ids []string) error {
// 	               panic("mock out the Delete method")
//             },
//             FilterFunc: func(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error) {
// 	               panic("mock out the Filter method")
//             },
//             GetOneFunc: func(id string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOne method")
//             },
//             GetOneActiveByHostFunc: func(host string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOneActiveByHost method")
//             },
//             GetOneByIDWithCreatorFunc: func(id string) (*domain.Domain, bool, error) {
// 	               panic("mock out the GetOneByIDWithCreator method")
//             },
//             ToggleActiveFunc: func(ids []string) error {
// 	               panic("mock out the ToggleActive method")
//             },
//         }
//
//         // use mockedStore in code that requires domain.Store
//         // and then make assertions.
//
//     }
type StoreMock struct {
	// AllFunc mocks the All method.
	AllFunc func() ([]*domain.Domain, bool, error)

	// AllForSiteIDFunc mocks the AllForSiteID method.
	AllForSiteIDFunc func(siteID string) ([]*domain.Domain, bool, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ids []string) error

	// FilterFunc mocks the Filter method.
	FilterFunc func(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error)

	// GetOneFunc mocks the GetOne method.
	GetOneFunc func(id string) (*domain.Domain, bool, error)

	// GetOneActiveByHostFunc mocks the GetOneActiveByHost method.
	GetOneActiveByHostFunc func(host string) (*domain.Domain, bool, error)

	// GetOneByIDWithCreatorFunc mocks the GetOneByIDWithCreator method.
	GetOneByIDWithCreatorFunc func(id string) (*domain.Domain, bool, error)

	// ToggleActiveFunc mocks the ToggleActive method.
	ToggleActiveFunc func(ids []string) error

	// calls tracks calls to the methods.
	calls struct {
		// All holds details about calls to the All method.
		All []struct {
		}
		// AllForSiteID holds details about calls to the AllForSiteID method.
		AllForSiteID []struct {
			// SiteID is the siteID argument value.
			SiteID string
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ids is the ids argument value.
			Ids []string
		}
		// Filter holds details about calls to the Filter method.
		Filter []struct {
			// Context is the context argument value.
			Context filters.QueryReader
		}
		// GetOne holds details about calls to the GetOne method.
		GetOne []struct {
			// ID is the id argument value.
			ID string
		}
		// GetOneActiveByHost holds details about calls to the GetOneActiveByHost method.
		GetOneActiveByHost []struct {
			// Host is the host argument value.
			Host string
		}
		// GetOneByIDWithCreator holds details about calls to the GetOneByIDWithCreator method.
		GetOneByIDWithCreator []struct {
			// ID is the id argument value.
			ID string
		}
		// ToggleActive holds details about calls to the ToggleActive method.
		ToggleActive []struct {
			// Ids is the ids argument value.
			Ids []string
		}
	}
	lockAll                   sync.RWMutex
	lockAllForSiteID          sync.RWMutex
	lockDelete                sync.RWMutex
	lockFilter                sync.RWMutex
	lockGetOne                sync.RWMutex
	lockGetOneActiveByHost    sync.RWMutex
	lockGetOneByIDWithCreator sync.RWMutex
	lockToggleActive          sync.RWMutex
}

// All calls AllFunc.
func (mock *StoreMock) All() ([]*domain.Domain, bool, error) {
	if mock.AllFunc == nil {
		panic("StoreMock.AllFunc: method is nil but Store.All was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAll.Lock()
	mock.calls.All = append(mock.calls.All, callInfo)
	mock.lockAll.Unlock()
	return mock.AllFunc()
}

// AllCalls gets all the calls that were made to All.
// Check the length with:
//     len(mockedStore.AllCalls())
func (mock *StoreMock) AllCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAll.RLock()
	calls = mock.calls.All
	mock.lockAll.RUnlock()
	return calls
}

// AllForSiteID calls AllForSiteIDFunc.
func (mock *StoreMock) AllForSiteID(siteID string) ([]*domain.Domain, bool, error) {
	if mock.AllForSiteIDFunc == nil {
		panic("StoreMock.AllForSiteIDFunc: method is nil but Store.AllForSiteID was just called")
	}
	callInfo := struct {
		SiteID string
	}{
		SiteID: siteID,
	}
	mock.lockAllForSiteID.Lock()
	mock.calls.AllForSiteID = append(mock.calls.AllForSiteID, callInfo)
	mock.lockAllForSiteID.Unlock()
	return mock.AllForSiteIDFunc(siteID)
}

// AllForSiteIDCalls gets all the calls that were made to AllForSiteID.
// Check the length with:
//     len(mockedStore.AllForSiteIDCalls())
func (mock *StoreMock) AllForSiteIDCalls() []struct {
	SiteID string
} {
	var calls []struct {
		SiteID string
	}
	mock.lockAllForSiteID.RLock()
	calls = mock.calls.AllForSiteID
	mock.lockAllForSiteID.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *StoreMock) Delete(ids []string) error {
	if mock.DeleteFunc == nil {
		panic("StoreMock.DeleteFunc: method is nil but Store.Delete was just called")
	}
	callInfo := struct {
		Ids []string
	}{
		Ids: ids,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ids)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedStore.DeleteCalls())
func (mock *StoreMock) DeleteCalls() []struct {
	Ids []string
} {
	var calls []struct {
		Ids []string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Filter calls FilterFunc.
func (mock *StoreMock) Filter(context filters.QueryReader) ([]*domain.Domain, filters.Filter, error) {
	if mock.FilterFunc == nil {
		panic("StoreMock.FilterFunc: method is nil but Store.Filter was just called")
	}
	callInfo := struct {
		Context filters.QueryReader
	}{
		Context: context,
	}
	mock.lockFilter.Lock()
	mock.calls.Filter = append(mock.calls.Filter, callInfo)
	mock.lockFilter.Unlock()
	return mock.FilterFunc(context)
}

// FilterCalls gets all the calls that were made to Filter.
// Check the length with:
//     len(mockedStore.FilterCalls())
func (mock *StoreMock) FilterCalls() []struct {
	Context filters.QueryReader
} {
	var calls []struct {
		Context filters.QueryReader
	}
	mock.lockFilter.RLock()
	calls = mock.calls.Filter
	mock.lockFilter.RUnlock()
	return calls
}

// GetOne calls GetOneFunc.
func (mock *StoreMock) GetOne(id string) (*domain.Domain, bool, error) {
	if mock.GetOneFunc == nil {
		panic("StoreMock.GetOneFunc: method is nil but Store.GetOne was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetOne.Lock()
	mock.calls.GetOne = append(mock.calls.GetOne, callInfo)
	mock.lockGetOne.Unlock()
	return mock.GetOneFunc(id)
}

// GetOneCalls gets all the calls that were made to GetOne.
// Check the length with:
//     len(mockedStore.GetOneCalls())
func (mock *StoreMock) GetOneCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetOne.RLock()
	calls = mock.calls.GetOne
	mock.lockGetOne.RUnlock()
	return calls
}

// GetOneActiveByHost calls GetOneActiveByHostFunc.
func (mock *StoreMock) GetOneActiveByHost(host string) (*domain.Domain, bool, error) {
	if mock.GetOneActiveByHostFunc == nil {
		panic("StoreMock.GetOneActiveByHostFunc: method is nil but Store.GetOneActiveByHost was just called")
	}
	callInfo := struct {
		Host string
	}{
		Host: host,
	}
	mock.lockGetOneActiveByHost.Lock()
	mock.calls.GetOneActiveByHost = append(mock.calls.GetOneActiveByHost, callInfo)
	mock.lockGetOneActiveByHost.Unlock()
	return mock.GetOneActiveByHostFunc(host)
}

// GetOneActiveByHostCalls gets all the calls that were made to GetOneActiveByHost.
// Check the length with:
//     len(mockedStore.GetOneActiveByHostCalls())
func (mock *StoreMock) GetOneActiveByHostCalls() []struct {
	Host string
} {
	var calls []struct {
		Host string
	}
	mock.lockGetOneActiveByHost.RLock()
	calls = mock.calls.GetOneActiveByHost
	mock.lockGetOneActiveByHost.RUnlock()
	return calls
}

// GetOneByIDWithCreator calls GetOneByIDWithCreatorFunc.
func (mock *StoreMock) GetOneByIDWithCreator(id string) (*domain.Domain, bool, error) {
	if mock.GetOneByIDWithCreatorFunc == nil {
		panic("StoreMock.GetOneByIDWithCreatorFunc: method is nil but Store.GetOneByIDWithCreator was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetOneByIDWithCreator.Lock()
	mock.calls.GetOneByIDWithCreator = append(mock.calls.GetOneByIDWithCreator, callInfo)
	mock.lockGetOneByIDWithCreator.Unlock()
	return mock.GetOneByIDWithCreatorFunc(id)
}

// GetOneByIDWithCreatorCalls gets all the calls that were made to GetOneByIDWithCreator.
// Check the length with:
//     len(mockedStore.GetOneByIDWithCreatorCalls())
func (mock *StoreMock) GetOneByIDWithCreatorCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetOneByIDWithCreator.RLock()
	calls = mock.calls.GetOneByIDWithCreator
	mock.lockGetOneByIDWithCreator.RUnlock()
	return calls
}

// ToggleActive calls ToggleActiveFunc.
func (mock *StoreMock) ToggleActive(ids []string) error {
	if mock.ToggleActiveFunc == nil {
		panic("StoreMock.ToggleActiveFunc: method is nil but Store.ToggleActive was just called")
	}
	callInfo := struct {
		Ids []string
	}{
		Ids: ids,
	}
	mock.lockToggleActive.Lock()
	mock.calls.ToggleActive = append(mock.calls.ToggleActive, callInfo)
	mock.lockToggleActive.Unlock()
	return mock.ToggleActiveFunc(ids)
}

// ToggleActiveCalls gets all the calls that were made to ToggleActive.
// Check the length with:
//     len(mockedStore.ToggleActiveCalls())
func (mock *StoreMock) ToggleActiveCalls() []struct {
	Ids []string
} {
	var calls []struct {
		Ids []string
	}
	mock.lockToggleActive.RLock()
	calls = mock.calls.ToggleActive
	mock.lockToggleActive.RUnlock()
	return calls
}
