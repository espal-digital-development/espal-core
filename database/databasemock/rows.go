// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package databasemock

import (
	"github.com/espal-digital-development/espal-core/database"
	"sync"
)

var (
	lockRowsMockClose sync.RWMutex
	lockRowsMockErr   sync.RWMutex
	lockRowsMockNext  sync.RWMutex
	lockRowsMockScan  sync.RWMutex
)

// Ensure, that RowsMock does implement database.Rows.
// If this is not the case, regenerate this file with moq.
var _ database.Rows = &RowsMock{}

// RowsMock is a mock implementation of database.Rows.
//
//     func TestSomethingThatUsesRows(t *testing.T) {
//
//         // make and configure a mocked database.Rows
//         mockedRows := &RowsMock{
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             ErrFunc: func() error {
// 	               panic("mock out the Err method")
//             },
//             NextFunc: func() bool {
// 	               panic("mock out the Next method")
//             },
//             ScanFunc: func(dest ...interface{}) error {
// 	               panic("mock out the Scan method")
//             },
//         }
//
//         // use mockedRows in code that requires database.Rows
//         // and then make assertions.
//
//     }
type RowsMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// NextFunc mocks the Next method.
	NextFunc func() bool

	// ScanFunc mocks the Scan method.
	ScanFunc func(dest ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Next holds details about calls to the Next method.
		Next []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Dest is the dest argument value.
			Dest []interface{}
		}
	}
}

// Close calls CloseFunc.
func (mock *RowsMock) Close() error {
	if mock.CloseFunc == nil {
		panic("RowsMock.CloseFunc: method is nil but Rows.Close was just called")
	}
	callInfo := struct {
	}{}
	lockRowsMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockRowsMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedRows.CloseCalls())
func (mock *RowsMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockRowsMockClose.RLock()
	calls = mock.calls.Close
	lockRowsMockClose.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *RowsMock) Err() error {
	if mock.ErrFunc == nil {
		panic("RowsMock.ErrFunc: method is nil but Rows.Err was just called")
	}
	callInfo := struct {
	}{}
	lockRowsMockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	lockRowsMockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//     len(mockedRows.ErrCalls())
func (mock *RowsMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	lockRowsMockErr.RLock()
	calls = mock.calls.Err
	lockRowsMockErr.RUnlock()
	return calls
}

// Next calls NextFunc.
func (mock *RowsMock) Next() bool {
	if mock.NextFunc == nil {
		panic("RowsMock.NextFunc: method is nil but Rows.Next was just called")
	}
	callInfo := struct {
	}{}
	lockRowsMockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	lockRowsMockNext.Unlock()
	return mock.NextFunc()
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//     len(mockedRows.NextCalls())
func (mock *RowsMock) NextCalls() []struct {
} {
	var calls []struct {
	}
	lockRowsMockNext.RLock()
	calls = mock.calls.Next
	lockRowsMockNext.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *RowsMock) Scan(dest ...interface{}) error {
	if mock.ScanFunc == nil {
		panic("RowsMock.ScanFunc: method is nil but Rows.Scan was just called")
	}
	callInfo := struct {
		Dest []interface{}
	}{
		Dest: dest,
	}
	lockRowsMockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	lockRowsMockScan.Unlock()
	return mock.ScanFunc(dest...)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//     len(mockedRows.ScanCalls())
func (mock *RowsMock) ScanCalls() []struct {
	Dest []interface{}
} {
	var calls []struct {
		Dest []interface{}
	}
	lockRowsMockScan.RLock()
	calls = mock.calls.Scan
	lockRowsMockScan.RUnlock()
	return calls
}
